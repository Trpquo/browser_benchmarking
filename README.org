* A Cross-Device and Cross-OS Benchmark of Modern Web Animation Systems

This is the repostiory for working on benchmarking scripts and techniques for comparing different browser mechanisms for creating animations and other layout effects.

** Application function description

For purpose described above, we created an application for paramtrically generating web animations using native web technologies, of which we count eight applicable approaches:
    1. =CSS= animations of absolutely postioned DOM elements in =HTML= structure
    2. =CSS= animations of DOM elements in =HTML= sturcture using its =transormations= engine
    3. =CSS= animations of DOM elements in =SVG= structure
    4. =CSS= aniations of DOM elements in =SVG= structure using CSS's =transformations= engine
    5. =JavaScript= animations of absolutely postitioned DOM elements in =HTML= structure using its ~requestAnimationFrame~ loop engine
    6. =JavaScript= animatios of DOM elements in =SVG= structure using its ~requestAnimationFrame~ loop engine
    7. =JavaScript= generated animations based on rendering images onscreen using =Canvas API= an JS's ~requestAnimationFrame~ loop engine
    8. =WebGL= rendered animations based on rendering images onscreen using =Canvas API= and =OpenGL= shader interpolation engine

Each of above mentioned animation technologies is native to all modern web browsers and each presents its unique approach to content display and animation rendition. HTML elements are objects present in the DOM and are subject to surrounding automated mechanisms for layout responsivity. Absolutely positioned HTML elements are exclueded from those mechanisms and require programatic coordinate asignment to deterimine their position on screen. SVG elements are similar in that matter, as they are part of the DOM structure and require coordinates, but are rendered through a different SVG engine. CSS features two distinct mechanisms for rendering animations. One is its /transition/ mechanism that can interpolate smooth transitions between any two states for any numerically valued DOM attribute. It is the basis of CSS animation API and its execution is primarily CPU based. Other is CSS transformation mechanism which doesn't act on browsers automatic layout mechanisms, but renders on top of it, and is optimized through the browser's compositing layer system and promoted to GPU rendering. Both of those mechanisms are applicable for animating HTML or SVG DOM elements. JavaScript is, in this scenario, a browser run programming language that can calculate representation for animation of any number of DOM attributes and then dynamically apply it to the DOM presentation. In this context, it is executed on the CPU in a single-threaded manner. Web animation API is also based on JavaScript and is used in this application to generate keyframe animation definitions to be run on CSS engine. Canvas API is another interface for JavaScript programs that doesn't render DOM elements, but rather presents a stage for programatically altering values of pixels in a grid bounded by ~<canvas>~ element's borders. Canvas API comes with many mathematical functions predefined for selecting geometrical areas of pixels. It also provides an interface for execution of WebGL instructions which come in shape of vertex array based shaders processed exclusively on GPUs. It is similar to CSS animations in a manner that it provides interface to provide just keyframe instructions for the animation and its native engine generates optimized machine instructions to be executed on hardware. Canvas API provides a JavaScript wrapper for contructing instructions in GLSL (OpenGL Shading Language) and sending them to the GPU for execution. In this application we use an abstraction of this layer in the form of popular library =tree.js=.  

Application developed here for testing performance of different web native animation technologies presents a simple user interface for defining parameters which deterimine the complexity of animation to be rendered on screen. The base concept of animation to be tested is a composition of arbitrarily large number of simple circular elements of same size and colour and layed out in a grid-like manner across the screen, each row accomodating for 50 of them. Elements are animated in a four segment animation, moving on a square shaped path with a side length equal to a width of each circle. Additional parameters control the intensification of complexity starting from the base animation. Increment parameter is of integer type and controls the number of elements needed to accomodate in render. Random motion parameter is a boolean that offsets each point of the square motion path by a random percentage of its size, ensuring in that way that each circle gets it's unique motion path which prevents global optimisations. Parameter of distance acts as a multplier on those path changes ensuring the frequent overalp of varius shapes. Parameter of random colour is also a boolean that adds to the animating requirements one of reaching a different random color on the end of each of four segments of animation loop. Parameter of blending does the same thing as that of random colour, but for elements opacity, making the rendering of elements' overlaps resource demanding. 

To ensure the comparability of gotten test results, this application preloads and reads-in all necessary scripts during its primary page load. In this way, any bandwith or connectivity issues are made irrelevant for measuring its execution. Each possible animation is run by a single parent function and all parent functions are developed to feature same code snippets for creating definitions for animations for each requested element and for running animation execution, varying only direct calls to respective animation API selected. Application code and its detailed documentation are made available for [[https://trpquo.github.io/browser_benchmarking/][viewing]] or [[https://github.com/Trpquo/browser_benchmarking][downloading]] on our public repository.

** User interface construction

Minimal graphic user interface of the application was build using native HTML and CSS technologies. HTML structure of the document presents simple form for entering generation parameters:

#+begin_src html :tangle index.html
  <!doctype html>
  <html>
      <head>
          <meta charset="UTF-8"/>
          <title>BB 4 CDCO-BMWAS</title>
  	<link href="style.css" rel="stylesheet"/>
      </head>
      <body>
  	<div class="formular">
  	    <form id="dashboard" method="post">
  		<fieldset>
  		    <legend>Main</legend>
  		    <label for="mode">Animation technique</label>
  		    <select id="mode" name="mode">
  			<option value="HTML+CSS">HTML + CSS</option>
  			<option value="SVG+CSS">SVG + CSS</option>
  			<option value="HTML+JS">HTML + JS</option>
  			<option value="SVG+JS">SVG + JS</option>
  			<option value="JS+Canvas">JS + Canvas</option>
  			<option value="WebGL+Canvas">WebGL + Canvas</option>
  		    </select>
  		    <span>
  			  <!-- applicable only for CSS animations -->
  			  <input name="transformations" id="transformations" type="checkbox" checked />
  			  <label for="transformations">Use transformations</label>
  		    </span>
  		</fieldset>
  		<fieldset>
  		    <legend>Options</legend>
  			<span>
  				<label for="count">Element count</label>
  				<input name="count" id="count" type="number" value="10" min="1" />
  			</span>
  			<span>
  				<input name="random" id="random" type="checkbox" checked />
  				<label for="random">Random movement</label>
  			</span>
  			<span>
  				<label for="distance">Distance</label>
  				<input name="distance" id="distance" type="number" value="2" min="1" max="20" />
  			</span>
  			<span>
  			  <input name="color" id="color" type="checkbox" checked />
  			  <label for="color">Random colors</label>
  			</span>
  			<span>
  				<input name="blending" id="blending" type="checkbox" checked />
  				<label for="blending">Add blending</label>
  			</span>
  		</fieldset>
  		<input title="animation" type="submit" value="Generate" />
  		<a title="documentation" href="https://github.com/Trpquo/browser_benchmarking" target="blank">&#x1F6C8;</a>
#+end_src

CSS styling continues this conservative trend to prevent taking over of system resources needed for rendering animations. 

#+begin_src css :tangle style.css

  :root, :root > * {
      margin: 0;
      padding: 0;
      font-size: max(.5vw, 16px);
  }
  #dashboard {
      padding: 1rem;
      padding-left: 220px;
      background-color: lightgray;
      position:relative;
      z-index: 10000;

      span {
  	white-space: nowrap;
  	&:not(:last-of-type) {
  	    padding-right: .5rem;
  	    margin-right: .5rem;
  	    border-right: 2px solid darkgray;
  	}
      }
      select + span {
  	padding-left: .5rem;
  	margin-left: .5rem;
  	border-left: 2px solid darkgray;
      }
      input[type=submit], a {
  	  padding: .5rem 1rem;
  	  background-color: forestgreen;
  	  color: white;
  	  border: 0;
  	  margin-top: 1rem;
  	  font-weight: bold;
  	  text-decoration: none;
  	  transition: background-color .1s;
  	  & + a {
  	      background-color: royalblue;
  	      padding: .40rem;
  	      margin-left: .25rem;
  	  }
  	  &:hover {
  	      background-color: darkslategray;
  	      cursor: pointer;
  	  }
  	  &:active {
  	      background-color: lightslategray;
  	  }
      }
      fieldset.fps {
  	float: right;
  	#fps {
  	    width: 4rem;
  	    background-color: #333;
  	    color: #df6;		     
  	    text-align: right;
  	}
  	label[for=fps_on] {
  	    display: none;
  	}
      }
  }

  #container {
      position: relative;
      padding-bottom: 20vh;

      div, span {
  	display: inline-block;
  	width: 2vw;
  	height: 2vw;
  	background-color: rgba(155,155,155,1);
  	border-radius: 50%;
  	animation-timing-function: linear;
      }
      svg {
  	overflow: visible;
  	g, circle {
  	    r: 1vw;
  	    fill: rgba(155,155,155,1);
  	    animation-timing-function: linear;
  	}
      }
      canvas {
  	display: block;
      }
  }
  .hidden {
      opacity: 0;
      transition: opacity .25s;
  }
#+end_src

** Defining and running animations

Three attrubutes are animated in all. Position of elements, their color and opacity. Elements displayed in animations are simple circular dots with width defined as 1/50th of the screen realestate. Their default color is gray, but can be animated to random colors. All animations are run in four segments marked by the time to translate over one edge of squared motion path.

*** Common parameters and functions

There are some common utility functions and global parameters that are defined in separtare file and placed into applications global context on pages first load.

#+begin_src js :tangle common.js
  // setting up dimentions of dots and other common animation parameters
  const dotsPerRow = 50 
  const dotDiameter = window.innerWidth / dotsPerRow
  const animation = {
      duration: 2000,
      segments: 4,
      iterations: Infinity
  }

  // common utility functions for generating random numbers when condition is met
  const random = (cond)=>cond === "on" ? Math.random() : 0;
  const spin = ()=> Math.random() < 0.5 ? -1 : 1;

  // function to calculate random offset from common path
  const push = (movement, multiplier)=>random(movement)*(dotDiameter/2)*multiplier*spin()

  // function to calculate random color values, from 150-255 per RGB color channel; and .3-1 for opacity
  const randomRGBA = (color, opacity)=>{
      const r = Math.round(155 + random(color) * 100 * spin())
      const g = Math.round(155 + random(color) * 100 * spin())
      const b = Math.round(155 + random(color) * 100 * spin())
      const a = opacity ? Math.random() * .7 + .3 : 1
      return {r,g,b,a}
  }
  const colorStr = ({r,g,b,a})=>`rgba(${r},${g},${b},${a})`
  // neutral color
  const gray = {r:155,g:155,b:155,a:1}
  const basicColor = colorStr(gray)
#+end_src

First commonly used function is the ~colorDistance~ calculator. It is based on finding the distance between two colors using pitagorean theorem: $d^2 = a^2 - b^2$ and is used througout the application to calculate the change in color needed in each animation frame. 

#+begin_src js :tangle common.js
  // color distance calculator
  const colorDistance = (c1, c2)=>{
      const dr = c1.r - c2.r
      const dg = c1.g - c2.g
      const db = c1.b - c2.b
      return Math.sqrt(dr*dr + dg*dg + db*db)
  }
#+end_src

Another especially useful and common function utilitzed in the application is the ~lerp~ function. The lerp function stands for Linear Interpolation. It’s a simple mathematical function that calculates a value between two numbers based on a parameter =t= that ranges from 0 to 1. Given two numbers =a= and =b=, and a parameter =t=: $lerp(a , b , t) = a + t × (b − a)$. When =t= = 0, the function returns =a=. When =t= = 1, the function returns =b=. When =t= is between 0 and 1, it returns a value proportionally between =a= and =b=. It’s typically used in animations to smoothly transition from one value to another.

#+begin_src js :tangle common.js
  // Linear interpolation
  function lerp(a, b, t) {
      return a + (b - a) * t;
  }
#+end_src

The most important common function for our purpose is the one that generates keyframes for all requested dots based on its input parameters.

#+begin_src js :tangle common.js
  // function that generates five animation keyframes based on user-defined parameters 
  const keyframesGenerator = (movement, multiplier, color, opacity)=>[
      {top: 0, left: 0, color: gray},
      {top: 0 + push(movement, multiplier), left: dotDiameter + push(movement, multiplier), color: randomRGBA(color, opacity)},
      {top: dotDiameter + push(movement, multiplier), left: dotDiameter + push(movement, multiplier), color: randomRGBA(color, opacity)},
      {top: dotDiameter + push(movement, multiplier), left: 0 + push(movement, multiplier), color: randomRGBA(color, opacity)},
      {top: 0, left: 0, color: gray},
  ] 
#+end_src

*** Parent functions to setup and start the animation processes

All parent functions catch user defined parameters as arguments in the same way.
#+name: catch-parameters
#+begin_src js 
  const { count, random:movement, distance:multiplier, color, blending:opacity } = settings
  let keyframes = [], dots = [], ctx = null // ctx test needed for Canvas clearance
#+end_src

**** For CSS driven animations

Special function is developed for defining and running CSS driven animations within HTML and SVG document structures. 

#+begin_src js :noweb yes :tangle css.js
  function CSSanimateElements(name, settings, container) {
      console.log('Animating with pure CSS.')
      <<catch-parameters>>
#+end_src

**** For JavaScript driven DOM element animations

Special function is built for defining and running JavaScript driven animations within HTML or SVG document structures.

#+begin_src js :noweb yes :tangle javaScript.js 
  function JSanimateElements(name, settings, container) {
      console.log('Animating with pure JavaScript.')
      <<catch-parameters>>
#+end_src

**** For JavaScript driven Canvas animations

Again, we firstly define the parent JavaScript function to catch user defined parameters for animation and then run functions for dots' array construction and animation rendering. In Canvas API (see [[https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API][MDN documentation]]), all characters are constructed virtually and then drawn onto ~<canvas>~ element, so the first task of our parent animation function is to create ~<canvas>~ element and place it onto our web pages staging area. Lastly, we define rendering context in which the animation will be realised.

#+begin_src js :noweb yes :tangle canvas.js
  function JSanimateCanvas(settings, container) {
     console.log('Animating on Canvas with JavaScript')
      <<catch-parameters>>
    const renderer = document.createElement("canvas")
    renderer.setAttribute('width', dotDiameter*50)
    renderer.setAttribute('height', dotDiameter*(10 + Math.ceil(count/50)))
    container.appendChild(renderer)

    ctx  = renderer.getContext('2d')
#+end_src

**** For WebGL driven Canvas animations

WebGL is a JavaScript API that renders high-performance 2D/3D graphics directly in the browser using the GPU, bypassing CPU limitations for smooth animations. In our application, WebGL (and its Three.js abstraction) drew arbitrary large number of animated circles efficiently in shaders by interpolating positions between keyframes on the GPU, unlike the plain JavaScript ~<span>~ or ~<circle>~ versions that updated DOM elements coordinate positions properties on the CPU each frame. This GPU acceleration enables scaling to massive particle counts with consistent 60fps performance, handling vertex position calculations and circular rendering in a single draw call. This would require completely new logic in constructing primary functions. To maintain consistency across the application in function definions, we are using the [[https://threejs.org][three.js]] JS abstraction layer. 

Firstly, we import needed =three.js= library files through initial loading page file requests.
#+name: threejs-imports
#+begin_src html
  	<script type="importmap">
  	 {"imports": {
  		 "three": "https://cdn.jsdelivr.net/npm/three@v0.181.2/build/three.module.js",
  		 "three/addons/": "https://cdn.jsdelivr.net/npm/three@v0.181.2/examples/jsm/"
  	 }}
  	</script>
#+end_src

Then we can define our parent animating function and in it we create and append to DOM ~<canvas>~ element with =WebGl= context, needed to render requested animations on screen.

#+begin_src js :noweb yes :tangle threeGL.js
  import * as THREE from 'three' 

  export default function GLanimateCanvas(settings, container) {
        console.log('Animating on Canvas with WebGL')
    	<<catch-parameters>>

        const scene = new THREE.Scene(),
	    sceneWidth = dotDiameter*50,
  	  sceneHeight = dotDiameter*(10 + Math.ceil(count/50))
        const camera = new THREE.OrthographicCamera(0, sceneWidth, sceneHeight, 0, -1000, 1000)
        camera.position.z = 10
        const renderer = new THREE.WebGLRenderer()
        const gray = 0x666666, white = 0xffffff;
        renderer.setSize(sceneWidth, sceneHeight)
        renderer.setClearColor(white, 1)
        container.appendChild(renderer.domElement)
#+end_src

*** Construction of dots array

All native web animation techniques tested with this application have to arrive its own method of constructing its dots' array primarily based on the fact of what the dots are going to be made of and what engine will render them.

There are still a lot of commonalities. They all use the same loop definition for creating dots' array and calculating their initial positions and color. The loop begins with calculating the correct initial position for each dot and creating keyframes for all four segments of animation in regards to the parameters for animation defined in the GUI.

#+name: dots-loop-start
#+begin_src js 
  for (let i=0; i < count; i++) {
      const col = i % dotsPerRow,
	  row = Math.floor(i / dotsPerRow),
	  x = col * dotDiameter,
	  y = row * dotDiameter
      let dot
      keyframes = keyframesGenerator(movement, multiplier, color, opacity)
#+end_src

The ending of common dot-creation loop stores all the attributes calculated based on user requested parameters of animation into an outer context's dots' array object.

#+name: dots-loop-end
#+begin_src js
      dots.push({
  	  el: dot,
  	  x,
  	  y,
  	  keyframes
      })
  }
#+end_src

**** For CSS driven DOM element animations

Parent function creates the array of dot elements with their initial postions and colorations and stores them in the ~dots~ array. The loop is then defined to create each needed element, place it onto documents animation stage and construct it's keyframes object.

#+begin_src js :noweb yes :tangle css.js
  <<dots-loop-start>>
      if (name === "span") {
  	dot = document.createElement(name)
      }
      else if (name === "circle") {
  	dot = document.createElementNS('http://www.w3.org/2000/svg', name)
      }
      else {
  	console.warn('Fatal error: Selected CSS animation option is not available!')
  	return
      }
      container.appendChild(dot)
  <<dots-loop-end>>
#+end_src

**** For JavaScript driven DOM element animations

For JavaScript driven animations, dots are made from ~<span>~ elements in HTML stucture, and from ~<circle>~ elements in SVG structure.

#+begin_src js :noweb yes :tangle javaScript.js 
      <<dots-loop-start>>

  if (settings.mode.indexOf('HTML') === 0) {
      dot = document.createElement(name)
      dot.style.position = "absolute"
      dot.style.left = x + "px"
      dot.style.top = y + "px"
  } else if (settings.mode.indexOf('SVG') === 0) {
      dot = document.createElementNS('http://www.w3.org/2000/svg', name)
      dot.setAttribute('cx', x)
      dot.setAttribute('cy', y)
  } else {
      console.warn("Fatal error: Selected JS animation option is not available!")
      return
  }
  container.appendChild(dot)

      <<dots-loop-end>>
#+end_src

**** For JavaScript driven Canvas animations

Next, the loop is created to calculate initial positions, colors and animation keyframes for all requested dot elements. Here, in contrast to CSS or JavaScript driven animations, we do not need to create or place any new DOM elements. 

#+begin_src js :noweb yes :tangle canvas.js
  <<dots-loop-start>>
  <<dots-loop-end>>
#+end_src

**** For WebGL driven Canvas animations

For WebGL rendering to be achieved, strings of GLSL (OpenGL Shading Language) code need to be formatted and sent directly to the GPU processing unit as shaders. Library wrapper =three.js= achieves this functionality for us, but we still need to provide it values for vertex and fragment shaders. We accomplish this through our common dots' array generating loop without the need to create or place any new DOM elements.

Before generating dot's array, it is advisable to separate out of the loop definitions that are common to all requested dot elements, and leave only ones specific to a certain dot to be recalculated in each loop iteration. 

#+begin_src js :tangle threeGL.js
    const geometry = new THREE.CircleGeometry(dotDiameter/2, 32) // minimal number of segments for visual comparability to other animation techniques
#+end_src

Because we need to accomodate for the need to test dot's color animations, defined by the /material/ of the dot, a new object needs to be created for each dot and keyframes parameters calculated for other animation methods need to be reclaibrated into new 2d vector objects.

#+begin_src js :noweb yes :tangle threeGL.js
  <<dots-loop-start>>

  const material = new THREE.MeshBasicMaterial({transparent: opacity==="on"}) // simplest material comparable to render of other animation techniques; transparency needs to be explicitly turned on for blending effects
  dot = new THREE.Mesh(geometry, material) // new object to represent dot in this frame
  dot.userData.basePos = new THREE.Vector2(x,y)
  dot.position.set(x,y,0)
  dot.userData.targetColor = new THREE.Color(basicColor)
  dot.userData.targetOpacity = 1
  scene.add(dot)

  <<dots-loop-end>>
#+end_src

*** Defining the main animation function to be run
**** For CSS driven animations

CSS is the only technology native to web browsers that has built in animation engines that calculates transitional points from few given keyframes as their destination points. Because of that, there is no need to start an animation loop. The only thing needed for animations to run is for them to be defined and applied to targeted dots present in array. This is achieved through defining a helper function ~animate~ which adapts its sideeffects according to user's request for animations relying on CSS's transform API or for animations relying on CSS's capabilities on transitioning through numerical values of its properties. In all of its implementations, helper function relies on JavaScript's =Web animation API= (see [[https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API][MDN documentation]]).

#+begin_src js :tangle css.js
  function animate(dot, transformations, SVG) {
      const definition = transformations ?
  	  dot.keyframes.map( ({top, left, color})=>({ transform: `translate(${top}px,${left}px)`, backgroundColor: colorStr(color), fill: colorStr(color)  }) ) :
  	      SVG ?
  	        dot.keyframes.map( ({top, left, color})=>({ cy:  `${dot.y + top}px`, cx:  `${dot.x + left}px`, fill: colorStr(color) }) ) :
  	        dot.keyframes.map( ({top, left, color})=>({ top: `${dot.y + top}px`, left: `${dot.x + left}px`, backgroundColor: colorStr(color) }) ) 
      if (!transformations && !SVG) { dot.el.style.position = "absolute"}
      dot.el.animate(definition, animation)
  }
#+end_src

All that is left to do is to activate the animation for each predefined dot element.

#+begin_src js :tangle css.js
  dots.forEach( dot=>{
      const SVG = settings.mode.indexOf('SVG') === 0
      if (SVG) {
  	dot.el.setAttribute('cy', dot.y + "px")
  	dot.el.setAttribute('cx', dot.x + "px")
      } else {
  	dot.el.style.top = dot.y + "px"
  	dot.el.style.left = dot.x + "px"
      }
     animate(dot, settings.transformations, SVG)     
  })
  }
#+end_src

**** Common steps to all programatically driven animations

Besides the CSS engine, all other native web animation techniques rely on programatically triggering the loop to redraw every frame of animation, and so each of them has it's own unuque way of implementing changes frame by frame. But, there still are many common elements for functions of all animation definitions regardless of animation technology.

#+name: animation-definition-start
#+begin_src js :noweb yes
  function animate(time=0) {
      const t = (time % animation.duration) / animation.duration,
  	  segmentIndex = Math.floor(t * animation.segments),
  	  segmentT = (t * animation.segments) - segmentIndex

      <<canvas-clearance>>

      dots.forEach(({el, x, y, keyframes})=> {
  	const start = keyframes[segmentIndex],
  	      end = keyframes[segmentIndex + 1]
  	      // Interpolated offsets
  	      const offsetY = lerp(start.top, end.top, segmentT),
  		    offsetX = lerp(start.left, end.left, segmentT),
  		    r = lerp(start.color.r, end.color.r, segmentT),
  		    g = lerp(start.color.g, end.color.g, segmentT),
  		    b = lerp(start.color.b, end.color.b, segmentT),
  		    a = lerp(start.color.a, end.color.a, segmentT),
  		    offsetColor = {r,g,b,a}
#+end_src

... and common endings of animation's function definition that alongside trigger the start of animations and keep them running until interrupted by some other process. Running of animations is accomplished through JavaScripts native ~requestAnimationFrame~ API (see [[https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame][MDN documentation]]) which call's for the run of ~animate~ function once from the outer respective animation triggering function and then recursively from within the ~animate~ function.

#+name: animation-definition-end
#+begin_src js
  	  });
  	  requestAnimationFrame(animate)
      }
      animate()
  }
#+end_src
**** For JavaScript driven animations of DOM elements

JavaScript run animation is defined so that it would update in change frame the positions of all dot elements by updateing ~style.left~ and ~style.right~ properties of absolutely positioned HTML elements, or, vice versa, the ~cx~ and ~cy~ attributes of SVG elements.

#+begin_src js :noweb yes :tangle javaScript.js
  <<animation-definition-start>>
  // Update CSS top and left properties | SVG cy and cx attributes
  if (settings.mode.indexOf('HTML') === 0) {
  	el.style.left = x + offsetX + "px"
  	el.style.top = y + offsetY + "px"
  	el.style.backgroundColor = colorStr(offsetColor)
  } else if (settings.mode.indexOf('SVG') === 0) {
  	el.setAttribute('cx', x + offsetX)
  	el.setAttribute('cy', y + offsetY)
  	el.style.fill = colorStr(offsetColor)
  }
  <<animation-definition-end>>
#+end_src

**** For JavaScript driven animations within Canvas framework

Animation based on Canvas' API is entirely run by JavaScript calculations of required dot positions and other property values. It uses predefined geometrical functions to define pixel areas on screen to be drawn at frame by frame.

To begin with, we define a function to draw dot's circle.

#+begin_src js :tangle canvas.js
  function drawDot(cx, cy, color, r=dotDiameter/2) {
      ctx.beginPath()
      ctx.arc(cx, cy, r, 0, 2*Math.PI)
      ctx.fillStyle = colorStr(color)
      ctx.fill()
      ctx.closePath()
  }
#+end_src

Then all that is left is to start the animation loop for each dot in an array and send drawing instructions to Canvas's rendering context.

#+begin_src js :noweb yes :tangle canvas.js
  <<animation-definition-start>>
        drawDot(x + offsetX, y + offsetY, offsetColor)
  <<animation-definition-end>>
#+end_src

And to clear Canvas' area on start of each animation loop.
#+name: canvas-clearance
#+begin_src js 
  if (ctx) { // needed for clearing Canvas' stage
  	ctx.clearRect(0, 0, renderer.width, renderer.height)
  } 
#+end_src

**** For WebGL driven animations within Canvas framework

And then we can define the animation function to be looped. Animation function also needs to accomodate that WebGLRenderer doesn't support =rgba= color space, so, in contrast to other techniques, the color definitions will have to be separated into color information and opacity information.

#+begin_src js :noweb yes :tangle threeGL.js
      <<animation-definition-start>>

  el.position.x = x + offsetX + dotDiameter
  el.position.y = sceneHeight - (y + offsetY + dotDiameter)

  const mat = el.material
  // Ensure colors are THREE.Color
  if (!(mat.color instanceof THREE.Color)) {
      mat.color = new THREE.Color(mat.color);
  }
  if (!(el.userData.targetColor instanceof THREE.Color)) {
      el.userData.targetColor = new THREE.Color(el.userData.targetColor);
  }
  // Create a temporary color to store lerp result
  if (!el.userData.currentColor) {
      el.userData.currentColor = mat.color.clone();
  }

  if (color==="on" || opacity==="on") {
      // Smoothly interpolate current color towards target color
      el.userData.currentColor.lerp(el.userData.targetColor, 0.02);

      // Update material color to current lerped color
      mat.color.copy(el.userData.currentColor);

      // Smoothly interpolate opacity
      mat.opacity = lerp(mat.opacity, el.userData.targetOpacity, 0.02);

      // When near target, pick new random color and opacity
      if (colorDistance(mat.color, el.userData.targetColor) < 0.02 &&
  	Math.abs(mat.opacity - el.userData.targetOpacity) < 0.02) {
  	const {r,g,b} = randomRGBA(color,opacity)
  	el.userData.targetColor = new THREE.Color(`rgb(${r},${g},${b})`)
  	el.userData.targetOpacity = Math.random() * 0.5 + 0.5;
      }	    
  }

    	  });
  	  renderer.render(scene, camera)
    	  requestAnimationFrame(animate)
        }
        animate()
    }
#+end_src

** Finalising the application 

Finally the script is attached to bind animation generating functions to the event of GUI form submition and to pass on needed user defined parameters for animations to their respective generative funcitons.

#+begin_src js :tangle script.js
  import GLanimateCanvas from './threeGL.js'

  const form = document.getElementById("dashboard")
  const container = document.getElementById("container")
  form.addEventListener('submit', renderAnimation)

  function renderAnimation(event) {
      event.preventDefault()
      const formData = new FormData(form)
      const settings = {}
      formData.forEach((value, key)=>{
  	settings[key] = value
      })
      container.innerHTML = "" // erase all content
      let svg

      switch(settings.mode) {
  	case "HTML+CSS":
  	    CSSanimateElements("span", settings, container)
  	    break;
  	case "SVG+CSS":
  	    svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg')
  	    svg.setAttributeNS(null, 'viewBox', `0 0 ${dotDiameter*50} ${dotDiameter*50}`)
  	    CSSanimateElements("circle", settings, svg)
  	    container.appendChild(svg)
  	    break;
  	case "HTML+JS":
  	    JSanimateElements("span", settings, container)
  	    break;
  	case "SVG+JS":
  	    svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg')
  	    svg.setAttributeNS(null, 'viewBox', `0 0 ${dotDiameter*50} ${dotDiameter*50}`)
  	    JSanimateElements("circle", settings, svg)
  	    container.appendChild(svg)
  	    break;
  	case "JS+Canvas":
  	    JSanimateCanvas(settings, container)
  	    break;
  	case "WebGL+Canvas":
  	    GLanimateCanvas(settings, container)
  	    break;
  	default:
  	    console.warn(`Action for ${settings.mode} is not defined.`)
      }
#+end_src

Additionally the onscreen FPS measurement tool is added to help track changes of hardware's abilty to generate number of frames frames per second. 

Script for measuring FPS during execution uses a trick of counting how many animatin frames it can run in during the runtime of application:

#+begin_src js :tangle fps.js
let FPSLoopRequest = false
let FPSFrameRequest = null

const fpsElem = document.getElementById('fps');

let lastTime = performance.now();
let frameCount = 0;

function fpsLoop(now, terminate) {
    if (FPSLoopRequest) {
	frameCount++;

	const delta = now - lastTime;
	// ažuriraj FPS otprilike svake sekunde
	if (delta >= 1000) {
            const fps = (frameCount * 1000) / delta;
            fpsElem.value = fps.toFixed(2);
            frameCount = 0;
            lastTime = now;
	}

	FPSFrameRequest = requestAnimationFrame(fpsLoop);
    } else {
	fpsElem.value = "OFF"
	cancelAnimationFrame(FPSFrameRequest)
    }
}

#+end_src

The main interaction script is then extended to include the functionality of truning the FPS counter on or off with the submission of requests of generating animations.

#+begin_src js :tangle script.js
    // turn FPS measurement ON/OFF
    if (settings.fps_on==="on") {
	if (FPSFrameRequest) {
	    cancelAnimationFrame(FPSFrameRequest)
	}
	FPSLoopRequest = true
	requestAnimationFrame(fpsLoop)
    } else {
	FPSLoopRequest = false
    }
}
#+end_src

Interface for the widget is attached to the bottom of the form.

#+begin_src html :tangle index.html
		<fieldset class="fps">
		    <legend>Measure</legend>
		    <input name="fps_on" id="fps_on" type="checkbox" />
		    <label for="fps_on">ON/OFF</label>
		    <input name="fps" id="fps" type="text" value="OFF"/>
		    <label for="fps">FPS</label>
		</fieldset>
	    </form>
	</div>
#+end_src

Additionally, another ~EventListener~ is added to ease the user interaction with dashboard by hiding settings not applicable to chosen type of animation.

#+begin_src js :tangle script.js
  const transformationsCheckbox = document.getElementById('transformations').parentNode,
        modeSelect = document.getElementById('mode')

  modeSelect.addEventListener('change', ()=>{
      if (modeSelect.value.indexOf('CSS') === -1) {
  	transformationsCheckbox.classList.add('hidden')
      } else {
  	transformationsCheckbox.classList.remove('hidden')
      }
  })
#+end_src

The user interface form is followed by empty ~<div>~ element for serving as the stage for placing elements to be animated.

#+begin_src html :tangle index.html
	<div id="container"></div>
#+end_src

And in the end, loaded interface document is instructed to read-in definitions needed for generating mentioned animations.

#+begin_src html :noweb yes :tangle index.html
    
  	<script src="common.js" type="text/javascript"></script>
  	<script src="css.js" type="text/javascript"></script>
  	<script src="javaScript.js" type="text/javascript"></script>
  	<script src="canvas.js" type="text/javascript"></script>
  	<<threejs-imports>>
  	<script src="threeGL.js" type="module"></script>
  	<script src="script.js" type="module"></script>
  	<script src="fps.js" type="text/javascript"></script>

      </body>
  </html>
#+end_src
